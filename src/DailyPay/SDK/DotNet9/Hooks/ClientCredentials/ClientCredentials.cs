//------------------------------------------------------------------------------
// <auto-generated>
// This code was generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
//
// Changes to this file may cause incorrect behavior and will be lost when
// the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#nullable enable

namespace DailyPay.SDK.DotNet9.Hooks.ClientCredentials
{
        using DailyPay.SDK.DotNet9.Models.Components;
        using DailyPay.SDK.DotNet9.Utils;
        using Newtonsoft.Json;
        using System;
        using System.Collections.Concurrent;
        using System.Collections.Generic;
        using System.Linq;
        using System.Net.Http;
        using System.Security.Cryptography;
        using System.Text;
        using System.Threading.Tasks;

    using PayloadValue = System.Collections.Generic.KeyValuePair<string?, string?>;

    public class TokenResponse
    {
        [JsonProperty("access_token")]
        public string AccessToken { get; private set; } = default!;

        [JsonProperty("token_type")]
        public string TokenType { get; private set; } = default!;

        [JsonProperty("expires_in")]
        public long? ExpiresIn { get; private set; }
    }

    public class Credentials
    {
        public string ClientID { get; private set; }
        public string ClientSecret { get; private set; }
        public string TokenURL { get; private set; }
        public List<string>? Scopes { get; private set; }

        public Credentials(string clientID, string clientSecret, string tokenURL, List<string>? scopes)
        {
            ClientID = clientID;
            ClientSecret = clientSecret;
            TokenURL = tokenURL;
            Scopes = scopes;
        }
    }

    public class Session
    {
        public Credentials Credentials { get; private set; }
        public string Token { get; private set; }
        public List<string> Scopes { get; private set; }
        public DateTime? ExpiresAt { get; private set; }

        public Session(Credentials credentials, string token, List<string> scopes, DateTime? expiresAt = null)
        {
            Credentials = credentials;
            Token = token;
            Scopes = scopes;
            ExpiresAt = expiresAt;
        }
    }

    public class ClientCredentialsHook : ISDKInitHook, IBeforeRequestHook, IAfterErrorHook
    {
        public ConcurrentDictionary<string, ConcurrentDictionary<string, Session>> Sessions { get; private set; } = new ConcurrentDictionary<string, ConcurrentDictionary<string, Session>>();
        public ISpeakeasyHttpClient Client = default!;

        public SDKConfig SDKInit(SDKConfig config)
        {
            Client = config.Client;
            return config;
        }

        private Boolean IsHookDisabled(HookContext hookCtx)
        {
            return hookCtx.Oauth2Scopes == null;
        }

        public async Task<HttpRequestMessage> BeforeRequestAsync(BeforeRequestContext hookCtx, HttpRequestMessage request)
        {
            if (IsHookDisabled(hookCtx))
            {
                return request;
            }

            var credentials = GetCredentials(hookCtx);
            if (credentials == null)
            {
                return request;
            }

            var sessionKey = GetSessionKey(credentials.ClientID, credentials.ClientSecret);
            var scopes = GetRequiredScopes(credentials, hookCtx);
            var session = GetExistingSession(sessionKey, scopes);

            if (session == null)
            {
                // Create new session
                session = await DoTokenRequestAsync(
                    hookCtx.BaseURL,
                    credentials,
                    scopes
                );

                var clientSessions = Sessions.GetOrAdd(
                    sessionKey,
                    _ => new ConcurrentDictionary<string, Session>()
                );

                var scopeKey = GetScopeKey(scopes);
                clientSessions[scopeKey] = session;
            }

            request.Headers.Remove("Authorization");
            request.Headers.Add("Authorization", $"Bearer {session.Token}");

            return request;
        }

        #pragma warning disable CS1998
        public async Task<(HttpResponseMessage?, Exception?)> AfterErrorAsync(AfterErrorContext hookCtx, HttpResponseMessage? response, Exception? error)
        {
            if (IsHookDisabled(hookCtx))
            {
                return (response, error);
            }

            if (error != null)
            {
                // We don't want to refresh the token if the error is not related to the token
                return (response, error);
            }

            var credentials = GetCredentials(hookCtx);
            if (credentials == null)
            {
                return (response, error);
            }

            if (response != null && response.StatusCode == System.Net.HttpStatusCode.Unauthorized)
            {
                var scopeKey = GetScopeKey(GetRequiredScopes(credentials, hookCtx));
                RemoveSession(GetSessionKey(credentials.ClientID, credentials.ClientSecret), scopeKey);
            }

            return (response, error);
        }
        #pragma warning restore CS1998

        private Credentials? GetCredentials(HookContext hookCtx)
        {

            if (hookCtx.SecuritySource == null)
            {
                return null;
            }

            return GetCredentialsGlobal(hookCtx.SecuritySource);
        }


        private Credentials? GetCredentialsGlobal(Func<object> securitySource)
        {
            var security = securitySource() as Security;

            if (security?.OauthClientCredentialsToken?.ClientID == null || security?.OauthClientCredentialsToken?.ClientSecret == null || security?.OauthClientCredentialsToken?.TokenURL == null)
            {
                return null;
            }

            return new Credentials(
                security?.OauthClientCredentialsToken?.ClientID!,
                security?.OauthClientCredentialsToken?.ClientSecret!,
                security?.OauthClientCredentialsToken?.TokenURL!,
                null
            );
        }

        private async Task<Session> DoTokenRequestAsync(string baseURL, Credentials credentials, List<string> scopes)
        {
            if( Client == null )
            {
                throw new Exception("SpeakeasyHttpClient not provided");
            }

            Uri tokenUri;
            try
            {
                tokenUri = new Uri(new Uri(baseURL), credentials.TokenURL);
            }
            catch (UriFormatException ex)
            {
                throw new Exception($"Failed to parse token URL: {ex}");
            }

            var request = new HttpRequestMessage
                {
                    Method = HttpMethod.Post,
                    RequestUri = tokenUri
                };

            var payload = new List<PayloadValue>
            {
                new PayloadValue("grant_type", "client_credentials"),
            };
            payload.Add(new PayloadValue("client_id", credentials.ClientID));
            payload.Add(new PayloadValue("client_secret", credentials.ClientSecret));

            if (scopes.Count > 0)
            {
                payload.Add(new PayloadValue("scope", string.Join(" ", scopes)));
            }

            request.Content = new FormUrlEncodedContent(payload);

            var response = await Client.SendAsync(request);
            var responseBody = await response.Content.ReadAsStringAsync();

            if (!response.IsSuccessStatusCode)
            {
                throw new Exception($"Unexpected status code {response.StatusCode}: {responseBody}");
            }

            TokenResponse tokenResponse;
            try
            {
                TokenResponse? obj = JsonConvert.DeserializeObject<TokenResponse?>(responseBody);
                if (obj == null)
                {
                    throw new Exception("Token response is null.");
                }
                tokenResponse = obj;
            }
            catch (Exception ex)
            {
                throw new Exception($"Failed to decode token response: {ex.Message}", ex);
            }

            if (tokenResponse == null)
            {
                throw new Exception("Failed to decode token response");
            }

            if (!string.Equals(tokenResponse!.TokenType, "Bearer", StringComparison.OrdinalIgnoreCase))
            {
                throw new Exception($"Unexpected token type {tokenResponse!.TokenType}");
            }

            if (tokenResponse.AccessToken == null)
            {
                throw new Exception("Failed to retrieve access token");
            }

            DateTime? expiresAt = null;
            if (tokenResponse!.ExpiresIn != null)
            {
                expiresAt = DateTime.UtcNow.AddSeconds(tokenResponse!.ExpiresIn!.Value);
            }

            return new Session(credentials, tokenResponse!.AccessToken, scopes, expiresAt);
        }

        private string GetSessionKey(string clientID, string clientSecret)
        {
            using (MD5 md5 = MD5.Create())
            {
                byte[] hashBytes = md5.ComputeHash(Encoding.UTF8.GetBytes($"{clientID}:{clientSecret}"));
                return BitConverter.ToString(hashBytes).Replace("-", "").ToLowerInvariant();
            }
        }

        private List<string> GetRequiredScopes(Credentials credentials, HookContext hookCtx)
        {
            return credentials.Scopes ?? hookCtx.Oauth2Scopes!;
        }

        private string GetScopeKey(List<string> scopes)
        {
            if (scopes == null)
            {
                return "";
            }

            if (scopes.Count == 0)
            {
                return "none";
            }

            return string.Join("&", scopes.OrderBy(s => s).ToList());
        }

        private Session? GetExistingSession(string sessionKey, List<string> requiredScopes)
        {
            if (!Sessions.TryGetValue(sessionKey, out var clientSessions))
            {
                return null;
            }

            var scopeKey = GetScopeKey(requiredScopes);

            if (clientSessions.TryGetValue(scopeKey, out var exactSession))
            {
                if (HasTokenExpired(exactSession.ExpiresAt))
                {
                    RemoveSession(sessionKey, scopeKey);
                }
                else
                {
                    return exactSession;
                }
            }

            // If no exact match was found, look for superset match
            foreach (var kvp in clientSessions)
            {
                var session = kvp.Value;
                if (HasTokenExpired(session.ExpiresAt))
                {
                    RemoveSession(sessionKey, kvp.Key);
                }
                else if (HasRequiredScopes(session.Scopes, requiredScopes))
                {
                    return session;
                }
            }

            return null;
        }

        private void RemoveSession(string sessionKey, string scopeKey)
        {
            if (Sessions.TryGetValue(sessionKey, out var clientSessions))
            {
                clientSessions.TryRemove(scopeKey, out _);
                if (clientSessions.IsEmpty)
                {
                    Sessions.TryRemove(sessionKey, out _);
                }
            }
        }

        private bool HasRequiredScopes(List<string> sessionScopes, List<string> requiredScopes)
        {
            return requiredScopes.All(requiredScope => sessionScopes.Contains(requiredScope));
        }

        /// <summary>
        /// Checks if the token has expired.
        /// If no `expires_in` field was returned by the authorization server, the token is considered to never expire.
        /// A 60-second buffer is applied to refresh tokens before they actually expire.
        /// </summary>
        private bool HasTokenExpired(DateTime? expiresAt)
        {
            return expiresAt != null && DateTime.UtcNow.AddSeconds(60) >= expiresAt;
        }

    }
}
